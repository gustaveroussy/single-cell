sobj@reductions <- sobj@reductions[keep.red]
}
## Restriction to the provided ident, if requested
if(remove.other.idents) {
cat("\nRemoving other idents ...\n")
idents.idx <- grep(pattern = '\\_res\\.', x = colnames(sobj@meta.data))
cur.ident.idx <- grep(pattern = paste0("^",ident), x = colnames(sobj@meta.data))
out.idents <- idents.idx[idents.idx != cur.ident.idx]
if(length(out.idents) > 0) sobj@meta.data <- sobj@meta.data[,-c(out.idents)]
}
## Translation
cat("\nTranslation names...\n")
sample.name <- Seurat::Project(sobj)
sobj@meta.data$sample <- as.factor(sobj@meta.data[[sample.colname]])
Seurat::Idents(sobj) <- sobj@meta.data[[ident]]
sample.colname = 'orig.ident'
force.assay = NULL
species = 'hg'
sample.name <- Seurat::Project(sobj)
sobj@meta.data$sample <- as.factor(sobj@meta.data[[sample.colname]])
Seurat::Idents(sobj) <- sobj@meta.data[[ident]]
sobj@meta.data$nUMI <- if(paste0('nCount_', assay) %in% colnames(sobj@meta.data)) sobj@meta.data[[paste0('nCount_', assay)]] else sobj@meta.data$nCount_RNA
sobj@meta.data$nGene <- if(paste0('nFeature_', assay) %in% colnames(sobj@meta.data)) sobj@meta.data[[paste0('nFeature_', assay)]] else sobj@meta.data$nFeature_RNA
if('percent_rb' %in% colnames(sobj@meta.data)) sobj@meta.data$percent_ribo <- sobj$percent_rb
projections_available <- names(sobj@reductions)
if(length(projections_available) >= 1){
projections_available_pca <- projections_available[grep(projections_available, pattern = 'pca', ignore.case = TRUE, invert = FALSE)]
if (length(projections_available_pca) >= 1){
for (projection in projections_available_pca){
new_projection <- stringr::str_replace(projection, "pca", "PrincipalComponentAnalysis")
sobj@reductions[new_projection]=sobj@reductions[projection]
sobj@reductions[projection]=NULL
}
}
}
reduction <- stringr::str_replace(reduction, "pca", "PrincipalComponentAnalysis")
print(reduction)
## Clean meta.data
cat("\nClean meta.data...\n")
sobj@meta.data[[sample.colname]] <- NULL
if(paste0('nCount_', assay) %in% colnames(sobj@meta.data)) sobj@meta.data[[paste0('nCount_', assay)]] <- NULL else sobj@meta.data$nCount_RNA <- NULL
if(paste0('nFeature_', assay) %in% colnames(sobj@meta.data)) sobj@meta.data[[paste0('nFeature_', assay)]] <- NULL else sobj@meta.data$nFeature_RNA <- NULL
if('percent_rb' %in% colnames(sobj@meta.data)) sobj@meta.data$percent_rb <- NULL
if('pcmito_inrange' %in% colnames(sobj@meta.data)) sobj@meta.data$pcmito_inrange <- NULL
if('pcribo_inrange' %in% colnames(sobj@meta.data)) sobj@meta.data$pcribo_inrange <- NULL
if('min_features' %in% colnames(sobj@meta.data)) sobj@meta.data$min_features <- NULL
if('min_counts' %in% colnames(sobj@meta.data)) sobj@meta.data$min_counts <- NULL
if('seurat_clusters' %in% colnames(sobj@meta.data)) sobj@meta.data$seurat_clusters <- NULL
percent_top_col = grep("percent_top_", colnames(sobj@meta.data), value = TRUE)
if(length(percent_top_col) > 0) sobj@meta.data[percent_top_col] <- NULL
## Add relationship tree based on dimension reduction
cat("\nAdd relationship tree...\n")
for (group in groups){
if(length(unique(sort(sobj@meta.data[[group]]))) >1 ){
Seurat::Idents(sobj) <- sobj@meta.data[[group]]
sobj@reductions$pca <- sobj@reductions[[reduction]]
dim_choosen = as.numeric(gsub("\\D", "", umap.name))
sobj <- Seurat::BuildClusterTree(sobj, dim=1:dim_choosen, reorder = FALSE, reorder.numeric = FALSE)
sobj@misc$trees[[group]] <- sobj@tools$'Seurat::BuildClusterTree'
sobj@reductions$pca <- NULL
}
}
sobj@tools <- list()
Seurat::Idents(sobj) <- sobj@meta.data[[ident]]
sobj@reductions$
reductionreduction
sobj@reductions
sobj@reductions[[reduction]]
group
groups
group="sample"
length(unique(sort(sobj@meta.data[[group]]))) >1
group="SCT_pca.23_res.0.5"
length(unique(sort(sobj@meta.data[[group]]))) >1
Seurat::Idents(sobj) <- sobj@meta.data[[group]]
sobj@reductions$pca <- sobj@reductions[[reduction]]
dim_choosen = as.numeric(gsub("\\D", "", umap.name))
sobj <- Seurat::BuildClusterTree(sobj, dim=1:dim_choosen, reorder = FALSE, reorder.numeric = FALSE)
sobj@misc$trees[[group]] <- sobj@tools$'Seurat::BuildClusterTree'
sobj@reductions$pca <- NULL
umap.name
print(sobj@reductions[[reduction]])
sobj
sobj@reductions
reduction
sobj@reductions[[reduction]]
min.cells=5
featureskeep <- Matrix::rowSums(sobj@assays$RNA@counts) >= min.cells
featureskeep
sobj@assays$RNA@counts[1:10,1:10]
sobj@assays$RNA@counts[1,1:10]
Matrix::rowSums(sobj@assays$RNA@counts[1:10,1:10])
summary(Matrix::rowSums(sobj@assays$RNA@counts))
featureskeep <- Matrix::rowSums(sobj@assays$RNA@counts) >= min.cells
featureskeep1 <- which(apply(sobj@assays$RNA@counts,1,function(x){length(which(x>0))})>=min.cells)
head(featureskeep1)
sobj@assays$RNA@counts(rownames(sobj@assays$RNA@counts)=="WASH7P")
sobj@assays$RNA@counts(rownames(sobj@assays$RNA@counts) = "WASH7P")
sobj@assays$RNA@counts(rownames(sobj@assays$RNA@counts) == "WASH7P")
sobj@assays$RNA@counts[rownames(sobj@assays$RNA@counts) == "WASH7P"]
sum(sobj@assays$RNA@counts[rownames(sobj@assays$RNA@counts) == "WASH7P"])
apply(sobj@assays$RNA@counts,1,function(x){length(which(x>0))})
featureskeep
featureskeep1
featureskeep <- Matrix::rowSums(sobj@assays$RNA@counts) >= min.cells
featureskeep1 <- which(apply(sobj@assays$RNA@counts,1,function(x){length(which(x>0))})>=min.cells)
head(featureskeep)
head(featureskeep1)
featureskeep1 <- which(apply(sobj@assays$RNA@counts,1,function(x){length(which(x>0))})>=min.cells)
head(featureskeep1)
featureskeep1 <- apply(sobj@assays$RNA@counts,1,function(x){length(which(x>0))}) >= min.cells
head(featureskeep1)
table(featureskeep1)
length(which(apply(sobj@assays$RNA@counts,1,function(x){length(which(x>0))}) >= min.cells))
length(apply(sobj@assays$RNA@counts,1,function(x){length(which(x>0))}) >= min.cells)
tab$a=c(0,1,1,1,1,1,0,0,0,0)
tab=data.frame()
tab$a=c(0,1,1,1,1,1,0,0,0,0)
tab
tab=as.data.frame("a"=c(0,1,1,1,1,1,0,0,0,0), "b"=c(0,1,1,1,1,1,0,0,0,1), "c"=c(0,0,0,0,0,0,0,0,0,0), "d"=c(0,1,1,1,1,0,0,0,0,0))
tab=data.frame("a"=c(0,1,1,1,1,1,0,0,0,0), "b"=c(0,1,1,1,1,1,0,0,0,1), "c"=c(0,0,0,0,0,0,0,0,0,0), "d"=c(0,1,1,1,1,0,0,0,0,0))
tab
min.cells
which(apply(tab,1,function(x){length(which(x>0))}) >= min.cells)
which(apply(tab,2,function(x){length(which(x>0))}) >= min.cells)
sobj@assays$RNA@misc$params$doublets$method_filtering
sobj@assays$RNA@misc$params
sobj@assays$RNA@misc
sobj@assays$RNA@misc
sobj@misc$parameters$cerebro <- list( groups = groups,
remove.other.reductions = remove.other.reductions),
remove.other.idents = remove.other.idents,
gmt.file = gmt.file,
remove.mt.genes = remove.mt.genes,
remove.crb.genes = remove.crb.genes,
remove.str.genes = remove.str.genes,
groups = groups,
groups = groups,
groups = groups,
)
R.Version()$version.string
R.Version()
getRversion()
pcmito.range[2]
pcmito.range=c(0,0.1)
pcmito.range[1]
pcmito.range[2]*100
pcribo.min <- 0
pcribo.max <- 1
pcribo.range <- c(pcribo.min, pcribo.max)
min.features <- 200
min.counts <- 1000
min.cells <- 5
doublets.filter.method <- 'all'
pcmito.range[1]
vtr
vtr=c(percent_mt, percent_rb, nFeature_RNA, percent_st, Cyclone.Phase)
vtr=c("nFeature_RNA", "percent_mt", "percent_rb", "percent_st","Cyclone.Phase")
vtr
vtr[vtr %in% c("nFeature_RNA", "percent_mt", "percent_rb", "percent_st")]
vtr[!vtr %in% c("nFeature_RNA", "percent_mt", "percent_rb", "percent_st")]
vtr[!vtr %in% c("nFeature_RNA", "percent_mt", "percent_rb", "percent_st", "Cyclone.Phase")]
length(vtr[!vtr %in% c("nFeature_RNA", "percent_mt", "percent_rb", "percent_st", "Cyclone.Phase")])
vtr
paste0(vtr[!vtr %in% c("nFeature_RNA", "percent_mt", "percent_rb", "percent_st")], collapse = ", ")
paste0(vtr[!vtr %in% c("nFeature_RNA", "percent_mt", "percent_rb", "percent_st", "Cyclone.Phase")], collapse = ", ")
paste0(vtr[!vtr %in% c("nFeature_RNA", "percent_mt")], collapse = ", ")
fruits <- c("one apple", "two pears", "three bananas")
str_replace(fruits, "[aeiou]", "-")
fruits <- c("one apple", "two pears", "three bananas")
stringr::str_replace(fruits, "[aeiou]", "-")
vtr
vtr1=vtr
# (percent_mt, percent_rb, nFeature_RNA, percent_st, Cyclone.Phase)
vtr <- stringr::str_replace(vtr, "sizeFactor", "number of detected transcripts")
vtr <- stringr::str_replace(vtr, "nFeature_RNA", "number of detected genes")
vtr <- stringr::str_replace(vtr, "percent_mt", "proportion of mitochondrial transcripts")
vtr <- stringr::str_replace(vtr, "percent_rb", "proportion of ribosomal transcripts")
vtr <- stringr::str_replace(vtr, "percent_st", "proportion of mechanical stress response transcripts")
vtr
dimred.method = 'pca'
norm.method = 'SCTransform'
vtr
vtr=vvtr
vtr=vtr1
vtr
### Materials and Methods
MM_tmp <- if(dimred.method == 'pca') 'PCA' else if(dimred.method == 'scbfa') 'scbfa'
if(!is.null(vtr)){
vtr <- stringr::str_replace(vtr, "sizeFactor", "the number of detected transcripts")
vtr <- stringr::str_replace(vtr, "nFeature_RNA", "the number of detected genes")
vtr <- stringr::str_replace(vtr, "percent_mt", "the proportion of mitochondrial transcripts")
vtr <- stringr::str_replace(vtr, "percent_rb", "the proportion of ribosomal transcripts")
vtr <- stringr::str_replace(vtr, "percent_st", "the proportion of mechanical stress response transcripts")
MM_tmp2 <- if(norm.method == 'SCTransform' && dimred.method == 'pca') paste0(" and regress out bias factors (",paste0(vtr, collapse = ", "),")") else if(norm.method == 'LogNormalize' && dimred.method == 'scbfa') paste0("Per-cell bias factors (including ", paste0(vtr, collapse = ", "),") were regressed out during the scBFA dimension reduction.")
}
paste0("Seurat (",sobj@misc$technical_info$Seurat,") was applied for further data processing.",
if(norm.method == 'SCTransform' && dimred.method == 'pca') { paste0("The SCTransform normalization method (Hafemeister C, Satija R. Normalization and variance stabilization of single-cell RNA-seq data using regularized negative binomial regression. Genome Biol. 2019;20 10.1186/s13059-019-1874-1.) was used to normalize, scale, select ",features.n," Highly Variable Genes", if(!is.null(vtr)) MM_tmp2,". Person residuals from this regression were used for dimension reduction by Principal Component Analysis (PCA).") },
if(norm.method == 'LogNormalize' && dimred.method == 'scbfa') { paste0("As the scBFA dimension reduction method (",sobj@misc$technical_info$scBFA,") is meant to be applied on a subset of the count matrix, we followed the authors recommendation and identified ",features.n," HVG (highly variable genes) using the FindVariableFeatures() method from Seurat (",sobj@misc$technical_info$Seurat,") applied on data transformed by its LogNormalize method. ", MM_tmp2)},
"The number of ",MM_tmp," dimensions to keep for further analysis was evaluated by assessing a range of reduced ",MM_tmp," spaces using ",dims.min," to ",dims.max," dimensions, with a step of ",dims.steps,". For each generated ",MM_tmp," space, Louvain clustering of cells was performed using a range of values for the resolution parameter from ",res.min," to ",res.max," with a step of ",res.steps,". The optimal space was manually evaluated as the one combination of kept dimensions and clustering resolution resolving the best structure (clusters homogeneity and compacity) in a Uniform Manifold Approximation and Projection space (UMAP). Additionaly, we used the clustree method (",sobj@misc$technical_info$clustree,") to assess if the selected optimal space corresponded to a relatively stable position in the clustering results tested for these dimensions / resolution combinations."
)
features.n=300
paste0("Seurat (",sobj@misc$technical_info$Seurat,") was applied for further data processing.",
if(norm.method == 'SCTransform' && dimred.method == 'pca') { paste0("The SCTransform normalization method (Hafemeister C, Satija R. Normalization and variance stabilization of single-cell RNA-seq data using regularized negative binomial regression. Genome Biol. 2019;20 10.1186/s13059-019-1874-1.) was used to normalize, scale, select ",features.n," Highly Variable Genes", if(!is.null(vtr)) MM_tmp2,". Person residuals from this regression were used for dimension reduction by Principal Component Analysis (PCA).") },
if(norm.method == 'LogNormalize' && dimred.method == 'scbfa') { paste0("As the scBFA dimension reduction method (",sobj@misc$technical_info$scBFA,") is meant to be applied on a subset of the count matrix, we followed the authors recommendation and identified ",features.n," HVG (highly variable genes) using the FindVariableFeatures() method from Seurat (",sobj@misc$technical_info$Seurat,") applied on data transformed by its LogNormalize method. ", MM_tmp2)},
"The number of ",MM_tmp," dimensions to keep for further analysis was evaluated by assessing a range of reduced ",MM_tmp," spaces using ",dims.min," to ",dims.max," dimensions, with a step of ",dims.steps,". For each generated ",MM_tmp," space, Louvain clustering of cells was performed using a range of values for the resolution parameter from ",res.min," to ",res.max," with a step of ",res.steps,". The optimal space was manually evaluated as the one combination of kept dimensions and clustering resolution resolving the best structure (clusters homogeneity and compacity) in a Uniform Manifold Approximation and Projection space (UMAP). Additionaly, we used the clustree method (",sobj@misc$technical_info$clustree,") to assess if the selected optimal space corresponded to a relatively stable position in the clustering results tested for these dimensions / resolution combinations."
)
dims.min=3
dims.max <- 49
dims.steps <- 2
res.max <- 1.2
res.min <- 0.1
res.steps <- 0.1
norm.method <- 'SCTransform'
dimred.method <- 'pca'
paste0("Seurat (",sobj@misc$technical_info$Seurat,") was applied for further data processing.",
if(norm.method == 'SCTransform' && dimred.method == 'pca') { paste0("The SCTransform normalization method (Hafemeister C, Satija R. Normalization and variance stabilization of single-cell RNA-seq data using regularized negative binomial regression. Genome Biol. 2019;20 10.1186/s13059-019-1874-1.) was used to normalize, scale, select ",features.n," Highly Variable Genes", if(!is.null(vtr)) MM_tmp2,". Person residuals from this regression were used for dimension reduction by Principal Component Analysis (PCA).") },
if(norm.method == 'LogNormalize' && dimred.method == 'scbfa') { paste0("As the scBFA dimension reduction method (",sobj@misc$technical_info$scBFA,") is meant to be applied on a subset of the count matrix, we followed the authors recommendation and identified ",features.n," HVG (highly variable genes) using the FindVariableFeatures() method from Seurat (",sobj@misc$technical_info$Seurat,") applied on data transformed by its LogNormalize method. ", MM_tmp2)},
"The number of ",MM_tmp," dimensions to keep for further analysis was evaluated by assessing a range of reduced ",MM_tmp," spaces using ",dims.min," to ",dims.max," dimensions, with a step of ",dims.steps,". For each generated ",MM_tmp," space, Louvain clustering of cells was performed using a range of values for the resolution parameter from ",res.min," to ",res.max," with a step of ",res.steps,". The optimal space was manually evaluated as the one combination of kept dimensions and clustering resolution resolving the best structure (clusters homogeneity and compacity) in a Uniform Manifold Approximation and Projection space (UMAP). Additionaly, we used the clustree method (",sobj@misc$technical_info$clustree,") to assess if the selected optimal space corresponded to a relatively stable position in the clustering results tested for these dimensions / resolution combinations."
)
norm.method="LogNormalize"
dimred.method="scbfa"
vtr=vtr1
### Materials and Methods
MM_tmp <- if(dimred.method == 'pca') 'PCA' else if(dimred.method == 'scbfa') 'scbfa'
MM_tmp
if(!is.null(vtr)){
vtr <- stringr::str_replace(vtr, "sizeFactor", "the number of detected transcripts")
vtr <- stringr::str_replace(vtr, "nFeature_RNA", "the number of detected genes")
vtr <- stringr::str_replace(vtr, "percent_mt", "the proportion of mitochondrial transcripts")
vtr <- stringr::str_replace(vtr, "percent_rb", "the proportion of ribosomal transcripts")
vtr <- stringr::str_replace(vtr, "percent_st", "the proportion of mechanical stress response transcripts")
vtr <- stringr::str_replace(vtr, "Cyclone.Phase", "the cell cycle phase determined by Cyclone")
vtr <- stringr::str_replace(vtr, "Seurat.Phase", "the cell cycle phase determined by Seurat")
MM_tmp2 <- if(norm.method == 'SCTransform' && dimred.method == 'pca') paste0(" and regress out bias factors (",paste0(vtr, collapse = ", "),")") else if(norm.method == 'LogNormalize' && dimred.method == 'scbfa') paste0("Per-cell bias factors (including ", paste0(vtr, collapse = ", "),") were regressed out during the scBFA dimension reduction.")
}
paste0("Seurat (",sobj@misc$technical_info$Seurat,") was applied for further data processing. ",
if(norm.method == 'SCTransform' && dimred.method == 'pca') { paste0("The SCTransform normalization method (Hafemeister C, Satija R. Normalization and variance stabilization of single-cell RNA-seq data using regularized negative binomial regression. Genome Biol. 2019;20 10.1186/s13059-019-1874-1.) was used to normalize, scale, select ",features.n," Highly Variable Genes", if(!is.null(vtr)) MM_tmp2,". Person residuals from this regression were used for dimension reduction by Principal Component Analysis (PCA).") },
if(norm.method == 'LogNormalize' && dimred.method == 'scbfa') { paste0("As the scBFA dimension reduction method (",sobj@misc$technical_info$scBFA,") is meant to be applied on a subset of the count matrix, we followed the authors recommendation and identified ",features.n," HVG (highly variable genes) using the FindVariableFeatures() method from Seurat (",sobj@misc$technical_info$Seurat,") applied on data transformed by its LogNormalize method. ", MM_tmp2)},
"The number of ",MM_tmp," dimensions to keep for further analysis was evaluated by assessing a range of reduced ",MM_tmp," spaces using ",dims.min," to ",dims.max," dimensions, with a step of ",dims.steps,". For each generated ",MM_tmp," space, Louvain clustering of cells was performed using a range of values for the resolution parameter from ",res.min," to ",res.max," with a step of ",res.steps,". The optimal space was manually evaluated as the one combination of kept dimensions and clustering resolution resolving the best structure (clusters homogeneity and compacity) in a Uniform Manifold Approximation and Projection space (UMAP). Additionaly, we used the clustree method (",sobj@misc$technical_info$clustree,") to assess if the selected optimal space corresponded to a relatively stable position in the clustering results tested for these dimensions / resolution combinations."
)
paste0(
"An automatic annotation of cell types was perfom by SingleR (",sobj@misc$technical_info$SingleR,") (with fine-tuning step) and ClustifyR (",sobj@misc$technical_info$clustifyr,"), using packages built-in references. It labels clusters (or cells) from a dataset based on similarity (Spearman correlation score) to a reference dataset with known labels. The labels with a correlation score greater than ",sr.minscore," for SingleR or greater than ",cfr.minscore," for ClustifyR were kept.
Marker genes for Louvain clusters were identified through a « one versus others » differential anaylisis using the Wilcoxon test through the FindAllMarkers() function from Seurat, considering only genes with a minimum log fold-change of 0.5 in at least 75 % of cells from one of the groups compared, and FDR-adjusted p-values <0.05 (Benjaminin-Hochberg method)."
)
cfr.minscore <- 0.35
sr.minscore <- 0.25
paste0(
"An automatic annotation of cell types was perfom by SingleR (",sobj@misc$technical_info$SingleR,") (with fine-tuning step) and ClustifyR (",sobj@misc$technical_info$clustifyr,"), using packages built-in references. It labels clusters (or cells) from a dataset based on similarity (Spearman correlation score) to a reference dataset with known labels. The labels with a correlation score greater than ",sr.minscore," for SingleR or greater than ",cfr.minscore," for ClustifyR were kept.
Marker genes for Louvain clusters were identified through a « one versus others » differential anaylisis using the Wilcoxon test through the FindAllMarkers() function from Seurat, considering only genes with a minimum log fold-change of 0.5 in at least 75 % of cells from one of the groups compared, and FDR-adjusted p-values <0.05 (Benjaminin-Hochberg method)."
)
### Materials and Methods
sobj@misc$Materials_and_Methods$Cerebro <- paste0("Cerebro (",utils::packageVersion('cerebroApp'),"), cell report browser, is an AppShiny which allows users to interactively visualize various parts of single cell transcriptomics analysis without requiring bioinformatics expertise. This package is also used to identify most expressed genes, and to compute pathway enrichment on marker genes (based on the Enrichr API) and Gene Set Enrichment Analysis (uses the Gene Set Variation Analysis method in combination with additional statistics as published by Diaz-Mejia et. al.(Diaz-Mejia JJ, Meng EC, Pico AR et al. Evaluation of methods to assign cell type labels to cell clusters from single-cell RNA-sequencing data [version 3; peer review: 2 approved, 1 approved with reservations]. F1000Research 2019, 8(ISCB Comm J):296 (https://doi.org/10.12688/f1000research.18490.3))) from the MSigDB (H collection: hallmark gene sets).")
### Materials and Methods
sobj@misc$Materials_and_Methods$part4_Clust_Markers_Annot <- paste0(
"An automatic annotation of cell types was perfom by SingleR (",sobj@misc$technical_info$SingleR,") (with fine-tuning step) and ClustifyR (",sobj@misc$technical_info$clustifyr,"), using packages built-in references. It labels clusters (or cells) from a dataset based on similarity (Spearman correlation score) to a reference dataset with known labels. The labels with a correlation score greater than ",sr.minscore," for SingleR or greater than ",cfr.minscore," for ClustifyR were kept.",
"Marker genes for Louvain clusters were identified through a «one versus others» differential anaylisis using the Wilcoxon test through the FindAllMarkers() function from Seurat, considering only genes with a minimum log fold-change of 0.5 in at least 75% of cells from one of the groups compared, and FDR-adjusted p-values <0.05 (Benjaminin-Hochberg method)."
)
sobj@misc$Materials_and_Methods$part3_Norm_DimRed_Eval <- paste0("Seurat (",sobj@misc$technical_info$Seurat,") was applied for further data processing. ",
if(norm.method == 'SCTransform' && dimred.method == 'pca') { paste0("The SCTransform normalization method (Hafemeister C, Satija R. Normalization and variance stabilization of single-cell RNA-seq data using regularized negative binomial regression. Genome Biol. 2019;20 10.1186/s13059-019-1874-1.) was used to normalize, scale, select ",features.n," Highly Variable Genes", if(!is.null(vtr)) MM_tmp2,". Person residuals from this regression were used for dimension reduction by Principal Component Analysis (PCA).") },
if(norm.method == 'LogNormalize' && dimred.method == 'scbfa') { paste0("As the scBFA dimension reduction method (",sobj@misc$technical_info$scBFA,") is meant to be applied on a subset of the count matrix, we followed the authors recommendation and identified ",features.n," HVG (highly variable genes) using the FindVariableFeatures() method from Seurat applied on data transformed by its LogNormalize method. ", MM_tmp2)},
"The number of ",MM_tmp," dimensions to keep for further analysis was evaluated by assessing a range of reduced ",MM_tmp," spaces using ",dims.min," to ",dims.max," dimensions, with a step of ",dims.steps,". For each generated ",MM_tmp," space, Louvain clustering of cells was performed using a range of values for the resolution parameter from ",res.min," to ",res.max," with a step of ",res.steps,". The optimal space was manually evaluated as the one combination of kept dimensions and clustering resolution resolving the best structure (clusters homogeneity and compacity) in a Uniform Manifold Approximation and Projection space (UMAP). Additionaly, we used the clustree method (",sobj@misc$technical_info$clustree,") to assess if the selected optimal space corresponded to a relatively stable position in the clustering results tested for these dimensions / resolution combinations."
)
### Materials and Methods
sobj@misc$Materials_and_Methods$part2_Filtering <- paste0("The count matrix was filtered to exclude genes detected in less than ",min.cells," cells, cells with less than ",min.counts," UMIs or less than ",min.features," detected genes, as well as cells with mitochondrial transcripts proportion higher than ",pcmito.range[2]*100,"%",
if(pcmito.range[1]=!0) paste0("and less than ",pcmito.range[1]*100, "%"),".",
if(pcribo.range[2]=!1 && pcribo.range[1]=!0) paste0("as well as cells with ribosomal transcripts proportion higher than ",pcribo.range[2]*100,"% and less than ",pcribo.range[1]*100, "%. The proportion of mechanical stress-response gene counts (Thesis of Léo Machado entitled « From skeletal muscle stem cells to tissue atlases: new tools to investigate and circumvent dissociation-induced stress », 2019) were also estimated but not used to filter cells.") else "The proportion of ribosomal gene counts and the proportion of mechanical stress-response gene counts (Thesis of Léo Machado entitled « From skeletal muscle stem cells to tissue atlases: new tools to investigate and circumvent dissociation-induced stress », 2019) were also estimated but not used to filter cells.",
"Cell cycle scoring of each cell was performed using two methods : the CellcycleScoring() function from the Seurat package (",sobj@misc$technical_info$Seurat,"), and the cyclone() function from Scran (",sobj@misc$technical_info$scran,").
Barcodes corresponding to doublet cells were identified and discarded using the union of two methods: scDblFinder (",sobj@misc$technical_info$scDblFinder,") using default parameters, and scds (",sobj@misc$technical_info$scds,") with its hybrid method using default parameters. We manualy verified that the cells identified as doublets did not systematically correspond to cells in G2M phase.")
pcmito.range[1]
pcribo.range[2]
pcribo.range[1]
pcribo.range[2]=!1
pcribo.range[2]
pcribo.range[2]=!"1"
str(pcribo.range[2])=!"1"
pcribo.range[2]=!1
!pcribo.range[2]==1
### Materials and Methods
sobj@misc$Materials_and_Methods$part2_Filtering <- paste0("The count matrix was filtered to exclude genes detected in less than ",min.cells," cells, cells with less than ",min.counts," UMIs or less than ",min.features," detected genes, as well as cells with mitochondrial transcripts proportion higher than ",pcmito.range[2]*100,"%",
if(!pcmito.range[1]==0) paste0("and less than ",pcmito.range[1]*100, "%"),".",
if(!pcribo.range[2]==1 && !pcribo.range[1]==0) paste0("as well as cells with ribosomal transcripts proportion higher than ",pcribo.range[2]*100,"% and less than ",pcribo.range[1]*100, "%. The proportion of mechanical stress-response gene counts (Thesis of Léo Machado entitled « From skeletal muscle stem cells to tissue atlases: new tools to investigate and circumvent dissociation-induced stress», 2019) were also estimated but not used to filter cells.") else "The proportion of ribosomal gene counts and the proportion of mechanical stress-response gene counts (Thesis of Léo Machado entitled « From skeletal muscle stem cells to tissue atlases: new tools to investigate and circumvent dissociation-induced stress», 2019) were also estimated but not used to filter cells.",
"Cell cycle scoring of each cell was performed using two methods: the CellcycleScoring() function from the Seurat package (",sobj@misc$technical_info$Seurat,"), and the cyclone() function from Scran (",sobj@misc$technical_info$scran,").
Barcodes corresponding to doublet cells were identified and discarded using the union of two methods: scDblFinder (",sobj@misc$technical_info$scDblFinder,") using default parameters, and scds (",sobj@misc$technical_info$scds,") with its hybrid method using default parameters. We manualy verified that the cells identified as doublets did not systematically correspond to cells in G2M phase.")
### Materials and Methods
sobj@misc$Materials_and_Methods$part1_Droplets_QC <- paste0("Cell barcode by symbol count table were loaded in R (version ", getRversion(), ") using the BUSpaRse package (", sobj@misc$technical_info$BUSpaRse,").
To call real cells from empty droplets, we used the emptyDrops() function from the dropletUtils (", sobj@misc$technical_info$DropletUtils,") package, which assesses whether the RNA content associated with a cell barcode is significantly distinct from the ambient background RNA present within each sample. Barcodes with p-value < ", emptydrops.fdr," (Benjamini–Hochberg-corrected) were considered as legitimate cells for further analysis.")
emptydrops.fdr=0.001
### Materials and Methods
sobj@misc$Materials_and_Methods$part1_Droplets_QC <- paste0("Cell barcode by symbol count table were loaded in R (version ", getRversion(), ") using the BUSpaRse package (", sobj@misc$technical_info$BUSpaRse,").
To call real cells from empty droplets, we used the emptyDrops() function from the dropletUtils (", sobj@misc$technical_info$DropletUtils,") package, which assesses whether the RNA content associated with a cell barcode is significantly distinct from the ambient background RNA present within each sample. Barcodes with p-value < ", emptydrops.fdr," (Benjamini–Hochberg-corrected) were considered as legitimate cells for further analysis.")
sobj@misc$Materials_and_Methods
data.path
data.path="/home/m_aglave/Bureau/0732M_GE/KALLISTOBUS"
readr::read_tsv(paste0(data.path, "/Materials_and_Methods.txt"),col_names = FALSE)
c(readr::read_tsv(paste0(data.path, "/Materials_and_Methods.txt"),col_names = FALSE))
readr::read_tsv(paste0(data.path, "/Materials_and_Methods.txt"),col_names = FALSE)$X1
rbind(readr::read_tsv(paste0(data.path, "/Materials_and_Methods.txt"),col_names = FALSE)$X1)
as.vector(readr::read_tsv(paste0(data.path, "/Materials_and_Methods.txt"),col_names = FALSE)$X1)
as.data.frame(readr::read_tsv(paste0(data.path, "/Materials_and_Methods.txt"),col_names = FALSE)$X1)
readr::read_tsv(paste0(data.path, "/Materials_and_Methods.txt"),col_types = col_character(), col_names = FALSE)
readr::read_tsv(paste0(data.path, "/Materials_and_Methods.txt"),col_types = col(col_character()), col_names = FALSE)
readr::read_tsv(paste0(data.path, "/Materials_and_Methods.txt"),col_types = (readr::col_character()), col_names = FALSE)
readr::read_tsv(paste0(data.path, "/Materials_and_Methods.txt"),col_types = readr::col(readr::col_character()), col_names = FALSE)
paste0(readr::read_tsv(paste0(data.path, "/Materials_and_Methods.txt"), col_names = FALSE))
readr::read_tsv(paste0(data.path, "/Materials_and_Methods.txt"), col_names = FALSE)
readtext
readtext()
read.table(paste0(data.path, "/Materials_and_Methods.txt"))
read.table(paste0(data.path, "/Materials_and_Methods.txt"),sep="--------------------------------------")
read.table(paste0(data.path, "/Materials_and_Methods.txt"),sep="....")
paste0(readr::read_tsv(paste0(data.path, "/Materials_and_Methods.txt"), col_names = FALSE)$X1)
a=readr::read_tsv(paste0(data.path, "/Materials_and_Methods.txt"), col_names = FALSE)$X1
paste0(a, sep="")
paste0(a, sep="")[1]
paste0(paste0(a, sep=""), sep="")
b=""
for (i in 1:4){
b=paste(b,a[i], sep="")
}
b
class(a)
paste(a)
paste(a, cep="")
paste(a, sep="")
tmp2
tmp <- readr::read_tsv(paste0(data.path, "/Materials_and_Methods.txt"), col_names = FALSE)$X1
tmp2 <- ""
for (i in 1:length(tmp)) tmp2=paste(tmp2,tmp[i], sep="")
sobj@misc$Materials_and_Methods$part0_Alignment <- tmp2
tmp2
tmp2 <- ""
for (i in 2:length(tmp)) tmp2=paste(tmp2,tmp[i], sep="")
sobj@misc$Materials_and_Methods$part0_Alignment <- tmp2
tmp2
tmp <- readr::read_tsv(paste0(data.path, "/Materials_and_Methods.txt"), col_names = FALSE)$X1
tmp2 <- ""
for (i in 1:length(tmp)) tmp2=paste(tmp2,tmp[i], sep="")
sobj@misc$Materials_and_Methods$part0_Alignment <- tmp2
tmp2
## Save Materials&Methods
if(file.exists(paste0(data.path, "/Materials_and_Methods.txt"))){
tmp <- readr::read_tsv(paste0(data.path, "/Materials_and_Methods.txt"), col_names = FALSE)$X1
tmp2 <- ""
for (i in 1:length(tmp)) tmp2=paste(tmp2,tmp[i], sep="")
sobj@misc$Materials_and_Methods$part0_Alignment <- tmp2
}
tmp2
as.numeric(NULL)
gene.names=c("q95","q95","q95","q95","q95","q95","q95","q95","q95","q95","q95","q95")
rep("q80", length(gene.names))
rownames(sobj)
length(rownames(sobj))
paste0(gene.names)
paste0(gene.names, sep=",")
paste0(gene.names, collapse=",")
paste0("The number of gene.names is not the same as the proteins in the ADT count table: ", length(gene.names), " genes (", paste0(gene.names, collapse=","),") and ",length(rownames(sobjADT)),"ADT (",paste0(rownames(sobjADT), collapse=","),").")
paste0("The number of gene.names is not the same as the proteins in the ADT count table: ", length(gene.names), " genes (", paste0(gene.names, collapse=","),") and ",length(rownames(sobj[1:10,1:10])),"ADT (",paste0(rownames(sobj[1:10,1:10]), collapse=","),").")
length(rownames(sobj)) != length(gene.names)
sobj@assays[[assay]]@misc$params$reductions
sobj@assays[[assay]]@misc$params$clustering
sobj@assays[[assay]]@misc$params$clustering[[ident.name]]
sobj@misc$params$clustering
sobj@misc$params$find.markers.quick
list(clustering = sobj@misc$params$find.markers.quick$ident,
method = sobj@misc$params$find.markers.quick$method,
min.pct = sobj@misc$params$find.markers.quick$min.pct,
logfs.threshold = sobj@misc$params$find.markers.quick$logfc.threshold,
adj.pval.threshold = sobj@misc$params$find.markers.quick$adjp.p.max)
list( method = sobj@misc$params$clustering$method,
algorithm = sobj@misc$params$clustering$algorithm,
dimensions = sobj@misc$params$clustering$dimensions,
resolution = sobj@misc$params$clustering$resolution,
umap = sobj@misc$params$clustering$umap,
name = sobj@misc$params$clustering$ident )
groups
paste0(groups, collapse = ", ")
sobj@misc$parameters$Materials_and_Methods$ADT
cor.method
paste0(NULL, "aaa")
vdj.input.file.tcr="/home/m_aglave/Bureau/0732M_TCR/0732M_TCR_CellRanger/outs/filtered_contig_annotations.csv"
paste0(dirname(vdj.input.file.tcr), "../../Materials_and_Methods.txt")
file.exists(paste0(dirname(vdj.input.file.tcr), "/../../Materials_and_Methods.txt"))
tmp <- readr::read_tsv(paste0(dirname(vdj.input.file.tcr), "/../../Materials_and_Methods.txt"), col_names = FALSE)$X1
tmp
tmp2 <- ""
for (i in 1:length(tmp)) tmp2=paste(tmp2,tmp[i], sep="")
tmp2
sobj@misc$parameters$Materials_and_Methods$TCR <- tmp2
sobj@misc$parameters$Materials_and_Methods$TCR
pipeline.path
pipeline.path="/home/m_aglave/Bureau/scRNAseq_10X_R4"
df_ref = read_excel(paste0(pipeline.path, "/resources/PACKAGES_REFRENCES/references.xlsx"))
df_ref = readxl::read_excel(paste0(pipeline.path, "/resources/PACKAGES_REFRENCES/references.xlsx"))
df_ref
df_ref = as.data.frame(readxl::read_excel(paste0(pipeline.path, "/resources/PACKAGES_REFRENCES/references.xlsx")))
df_ref
df_ref = readxl::read_excel(paste0(pipeline.path, "/resources/PACKAGES_REFRENCES/references.xlsx"))
df_ref
MandM=sobj@misc$parameters$Materials_and_Methods
MandM
names(MandM)
for (i in length(df_ref$package_name)){
for (j in names(MandM)){
if (grep(df_ref$package_name[i], MandM[j])){
print(df_ref$package_name[i])
}
}
}
grep(df_ref$package_name[i], MandM[j])
grepl(df_ref$package_name[i], MandM[j])
MandM[j]
for (i in length(df_ref$package_name)){
for (j in names(MandM)){
if (grepl(df_ref$package_name[i], MandM[j], ignore.case = TRUE)){
print(df_ref$package_name[i])
}
}
}
df_ref$package_name[i]
i=9
df_ref$package_name[i]
i=8
df_ref$package_name[i]
j
grepl(df_ref$package_name[i], MandM[j], ignore.case = TRUE)
for (i in length(df_ref$package_name)){
print(df_ref$package_name[i])
for (j in names(MandM)){
print(j)
if (grepl(df_ref$package_name[i], MandM[j], ignore.case = TRUE)){
print("Find!!!")
}
}
}
for (i in 1:length(df_ref$package_name)){
print(df_ref$package_name[i])
for (j in names(MandM)){
print(j)
if (grepl(df_ref$package_name[i], MandM[j], ignore.case = TRUE)){
print("Find!!!")
}
}
}
capture.output(devtools::session_info())
class(capture.output(devtools::session_info()))
df_ref
df_ref = readxl::read_excel(paste0(pipeline.path, "/resources/PACKAGES_REFRENCES/references.xlsx"))
df_res = dataframe(package_name=character(), reference=character())
df_res = data.frame(package_name=character(), reference=character())
df_ref = readxl::read_excel(paste0(pipeline.path, "/resources/PACKAGES_REFRENCES/references.xlsx"))
df_res = data.frame(package_name=character(), reference=character())
for (i in 1:length(df_ref$package_name)){
print(df_ref$package_name[i])
for (j in names(MandM)){
print(j)
if (grepl(df_ref$package_name[i], MandM[j], ignore.case = TRUE)){
print("Find!!!")
if(! df_ref$package_name[i] %in% df_res$package_name){
df_res <- rbind(df_res, df_ref[i,])
}
}
}
}
df_res
df_res = data.frame(package_name=character(), reference=character())
for (i in 1:length(df_ref$package_name)){
print(df_ref$package_name[i])
for (j in names(MandM)){
print(j)
if ((grepl(df_ref$package_name[i], MandM[j], ignore.case = TRUE)) && (! df_ref$package_name[i] %in% df_res$package_name)) df_res <- rbind(df_res, df_ref[i,])
}
}
df_res
df_ref
df_ref = readxl::read_excel(paste0(pipeline.path, "/resources/PACKAGES_REFRENCES/references.xlsx"))
df_ref
df_ref[10,]
df_ref[10,]$reference
df_ref = readxl::read_excel(paste0(pipeline.path, "/resources/PACKAGES_REFRENCES/references.xlsx"))
df_ref[10,]$reference
df_ref = readxl::read_excel(paste0(pipeline.path, "/resources/PACKAGES_REFRENCES/references.xlsx"))
df_ref[10,]$reference
df_ref[11,]$reference
df_ref = readxl::read_excel(paste0(pipeline.path, "/resources/PACKAGES_REFRENCES/references.xlsx"))
df_ref[11,]$reference
sobj@misc$technical_info$Seurat <- utils::packageVersion('Seurat')
#### Fixed parameters ####
multi.pt.size <- solo.pt.size <- 2
norm.method=NULL
norm.method == 'SCTransform'
if (norm.method == 'SCTransform') vtr else NULL
if(integration.method %in% c("Seurat","Liger")) { #keep normalisation
n.meth <- sapply(seq_along(sobj.list), function(x) { sobj.list[[x]]@misc$params$normalization$normalization.method })
if(length(unique(n.meth)) != 1) stop(paste0("We can't mix several normalisation method with ",integration.method,": ",paste0(n.meth, collapse = ", ")))
assay <- sobj.list[[1]]@misc$params$normalization$assay.out
norm.method <- unique(n.meth)
}
## Get species parameter
species <- sapply(seq_along(sobj.list), function(x) { sobj.list[[x]]@misc$params$species })
### Add prefix for colnames of sample clustering and clean TCR/BCR
for (i in names(sobj.list)){
# add prefix for colnames of sample clustering
to_rename=grep("_res\\.",colnames(sobj.list[[i]]@meta.data), value = TRUE)
for (j in to_rename){
sobj.list[[i]]@meta.data[[paste0(i,'_',j)]]=sobj.list[[i]]@meta.data[[j]]
sobj.list[[i]]@meta.data[[j]]=NULL
}
# cleaning sobj for TCR and BCR part
TCR_BCR_col=grep("^TCR|^BCR", colnames(sobj.list[[i]]@meta.data), value = TRUE)
if(length(TCR_BCR_col) > 0) sobj.list[[i]]@meta.data[TCR_BCR_col] <- NULL
}
